{"slots":{"0":{"name":"core","type":{"events":[],"methods":[]}},"1":{"name":"display","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"local width = system.getScreenWidth()/2\nlocal height = system.getScreenHeight()/2\n\npitch, roll, heading = -70,0,0\n\ndist = 1000\nclosed = false\nmirror = false\nline = false\nelementCount = #core.getElementIdList()\n\n--I suggest you use 90 degress for the FOV\nlocal fov = system.getFov() / 2\nlocal sin = math.sin\nlocal cos = math.cos\nlocal tan = math.tan\nlocal rad = math.rad\n\nlocal near = (width)/tan(rad(fov/2))\nlocal far = 100000\n\nlocal aspect = system.getScreenWidth()/system.getScreenHeight()\n\nlocal top = near * tan(rad( fov * 0.5 ));\nlocal bottom = -top;\nlocal left = bottom * aspect;\nlocal right = top * aspect;\nlocal x0 = 2 * near / ( right - left )\nlocal y0 = 2 * near / ( top - bottom )\n\nlocal a0 = (right + left) / (right - left)\nlocal b0 = (top + bottom) / (top - bottom)\nlocal c0 = -(far + near) / (far - near)\nlocal d0 = -2 * far * near / (far - near)\n\nfunction getMatrix(hO, pO, rO, hC, pC, rC, eye)\n    local sinrO = sin(rO)\n    local sinhO = sin(hO)\n    local sinpO = sin(pO)\n    \n    local cosrO = cos(rO)\n    local coshO = cos(hO)\n    local cospO = cos(pO)\n    \n    local sinrC = sin(rC)\n    local sinhC = sin(hC)\n    local sinpC = sin(pC)\n    \n    local cosrC = cos(rC)\n    local coshC = cos(hC)\n    local cospC = cos(pC)\n    \n    \n    local a1 = coshO*cosrO\n    local b1 = coshO*sinrO*sinpO-sinhO*cospO\n    local c1 = coshO*sinrO*cospO+sinhO*sinpO\n    \n    local d1 = sinhO*cosrO\n    local e1 = sinhO*sinrO*sinpO+coshO*cospO\n    local f1 = sinhO*sinrO*cospO-coshO*sinpO\n    \n    local g1 = -sinrO\n    local h1 = cosrO*sinpO\n    local i1 = cosrO*cospO\n    \n    local a2 = coshC*cosrC\n    local b2 = coshC*sinrC*sinpC-sinhC*cospC\n    local c2 = coshC*sinrC*cospC+sinhC*sinpC\n    \n    local d2 = sinhC*cosrC\n    local e2 = sinhC*sinrC*sinpC+coshC*cospC\n    local f2 = sinhC*sinrC*cospC-coshC*sinpC\n    \n    local g2 = -sinrC\n    local h2 = cosrC*sinpC\n    local i2 = cosrC*cospC\n    \n    local eyeX = eye[1]\n    local eyeY = eye[2]\n    local eyeZ = eye[3]\n    local dotX = a2*eyeX + b2*eyeY + c2*eyeZ\n    local dotY = d2*eyeX + e2*eyeY + f2*eyeZ\n    local dotZ = g2*eyeX + h2*eyeY + i2*eyeZ\n    \n    return {\n        a1, b1, c1,\n        d1, e1, f1,\n        g1, h1, i1\n    }, {\n        a2, b2, c2, -dotX,\n        d2, e2, f2, -dotY,\n        g2, h2, i2, -dotZ\n    }\nend\n\nfunction project(objs, model, view, offset)\n    \n    -- Localize model matrix values\n    local mx1 = model[1]\n    local my1 = model[2]\n    local mz1 = model[3]\n    --local mw1 = model[4]\n    local mx2 = model[4]\n    local my2 = model[5]\n    local mz2 = model[6]\n    --local mw2 = model[8]\n    local mx3 = model[7]\n    local my3 = model[8]\n    local mz3 = model[9]\n    --local mw3 = model[12]\n    \n    -- Localize view matrix values\n    local vx1 = view[1]\n    local vy1 = view[2]\n    local vz1 = view[3]\n    local vw1 = view[4]\n    local vx2 = view[5]\n    local vy2 = view[6]\n    local vz2 = view[7]\n    local vw2 = view[8]\n    local vx3 = view[9]\n    local vy3 = view[10]\n    local vz3 = view[11]\n    local vw3 = view[12]\n    \n    -- Localize projection matrix values used\n    local projX = x0\n    local projY = y0\n    \n    local height = height\n    local width = width\n    \n    local objs = objs\n    local offsetX = offset[1]\n    local offsetY = offset[2]\n    local offsetZ = offset[3]\n    \n    local processed = {}\n    local c1 = 1\n    for i = 1, #objs do\n        local line = objs[i]\n        processed[c1] = {}\n        local c2 = 1\n        for d = 1, #line do\n            local point = line[d]\n            local x = -(point[1] + offsetX)\n            local y = point[2] + offsetY\n            local z = point[3] + offsetZ\n            \n            --Manually calculate the \"model\" transformation, object rotations, to be a world-space point\n            local mx = x*mx1 + y*mx2 + z*mx3\n            local my = x*my1 + y*my2 + z*my3\n            local mz = x*mz1 + y*mz2 + z*mz3\n\n            -- Manually calculate the \"view\" transformation, your camera rotations, to view-space\n            local vx = mx*vx1 + my*vx2 + mz*vx3 + vw1\n            local vy = mx*vy1 + my*vy2 + mz*vy3 + vw2\n            local vz = mx*vz1 + my*vz2 + mz*vz3 + vw3\n\n            -- Manually calculate the \"projection\" matrix and convert them to clip coordinates.\n            local px = projX * vx\n            local py = projY * vy\n\n            local pw = vz * -1\n\n            -- Convert to window coordinates after W-Divide\n            local wx = (px / pw) * width\n            local wy = (py / pw) * height\n\n            if pw > 0 then\n                processed[c1][c2] = {wx, wy}\n                c2 = c2 + 1\n            end\n        end\n        c1 = c1 + 1\n    end\n    return processed\nend\n\npointsArray = {\n    {},\n    {}\n}\nlevel = #pointsArray\n\nlocal maths = require(\"cpml.utils\")\n--[[ \nElias kindly allowed me to use this to profile and optimize the script.\nIt has been an enormous help in many ways. If you want to use it as well\nthen I suggest you check out https://github.com/EliasVilld/du-logger/ for more info.\nFor me, I use the following names to describe each action\n - logUpdate (Total time of tick(update) to execute)\n - logFixed (Total time of tick(fixed_1) to execute)\n - logCompute (Time for creation of rotation matrices)\n - logProject (Time for the points to be projected)\n - logRender (Time adding the projected points into a path format)\n - logConcat (Time to concatenate the table)\n - logOther (Time for displaying these metrics and the other screen elements)\n]]--\nfunction Log(name,ty)\n    local self={}\n    self.Name = name or 'Log'\n    self.Value = (ty == 'int' and 0) or {}\n    self.Type = ty or 'int'\n    self.Id = 0\n    \n    if self.Type == 'range' then self.Value = {0,0} end\n\n    function self.Update(v)\n        self.Value[#self.Value] = v\n    end\n\n    function self.getString()\n        if self.Type == 'int' then\n            return self.value\n        elseif self.Type == 'time' then\n            return maths.round(self.getMean()*1000,0.001) .. 'ms'\n        elseif self.Type == 'range' then\n            return self.Value[1] * 1000 .. '/' .. self.Value[2] * 1000;\n        end\n    end\n    \n    function self.getValue()\n        if self.Type == 'int' then\n            return self.value\n        elseif self.Type == 'time' then\n            return self.getMean()\n        elseif self.Type == 'range' then\n            return self.Value[1];\n        end\n    end\n        \n    function self.addValue(v)\n        if type(self.Value) ~= 'table' then self.Value = {} end\n        table.insert(self.Value,1,v)\n        if #self.Value > 200 then self.Value[201] = nil end\n    end\n    \n    function self.getMean()\n        local m = 0;\n        for i=1,#self.Value do\n            m = m + self.Value[i]\n        end\n        return m/#self.Value;\n    end\n\n    return self\nend\n\n\nfunction Logger()\n    local self={}\n    self.Logs={}\n\n    function self.CreateLog(name,type)\n        local log = Log(name,type)\n        local id = Register(log)\n        log.Id = id;\n        return log;\n    end\n    \n    function self.getLogs()\n        local logs = {}\n        for _,l in pairs(self.Logs) do\n            logs[#logs+1] = l.Name .. ': ' .. l.getString()\n        end\n        return logs\n    end\n    \n    function Register(log)\n        self.Logs[#self.Logs+1] = log;\n        return #self.Logs\n    end\n    return self\nend\n\n--Define logs\nLogs = Logger()\nlogUpdate = Logs.CreateLog(\"Update\", \"time\")\nlogFixed = Logs.CreateLog(\"Fixed\", \"time\")\nlogCompute = Logs.CreateLog(\"Compute\", \"time\")\nlogProject = Logs.CreateLog(\"Project\", \"time\")\nlogRender = Logs.CreateLog(\"Render\", \"time\")\nlogConcat = Logs.CreateLog(\"Concat\", \"time\")\nlogOther = Logs.CreateLog(\"Other\", \"time\")\n\n--Define the root of the rendering\n-- Full Credit to Elias for this.\nroot = [[<style>svg{ width:]]..width*2 ..[[px; height:]]..height*2 ..[[px; position:absolute; top:0px; left:0px;}\n.white{ stroke: white; stroke-width:1; fill: none;}\n.green{ stroke: green; stroke-width:1; fill: none;}\n</style><svg viewBox=\"0 0 ]]..width*2 ..[[ ]]..height*2 ..[[\">\n<g transform=\"translate(]]..width ..[[,]]..height ..[[) scale(1)\">]]\n\n-- Start Timers\nunit.setTimer(\"fixed_1\", 1/30)\n--unit.setTimer(\"fixed_2\", 1/1000)\nunit.setTimer(\"update\", 1/30)\nsystem.showScreen(1)\n\nlocal number = 0\nfor i,v in ipairs(pointsArray) do\n    number = number + #v\nend\nsystem.print(\"Total Points: \" .. number)","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"0"},{"code":"local t0 = system.getTime()\n\n--Declare frequently checked variables as local\nlocal level = level\nlocal mirror = mirror\n\n--Declare the render and init with the root (Credit to Elias)\nlocal render = {root}\nlocal c = 2\nlocal ship = ship\nrender[c] = '<path class=\"white\" d=\"'\nc = c + 1\nif ship ~= nil and #ship ~= 0 then\n    for i = 1,#ship do\n        local line = ship[i]\n        if line ~= nil and #line > 1 then\n            render[c] = 'M '\n            local startPoint = line[1]\n            local endPoint = line[1]\n            render[c + 1] = startPoint[1]\n            render[c + 2] = ' '\n            render[c + 3] = startPoint[2]\n            c = c + 4\n            for p = 2, #line do\n                local point = line[p]\n                render[c] = ' L '\n                render[c+1] = point[1]\n                render[c+2] = ' '\n                render[c+3] = point[2]\n                c = c+4\n            end\n            local endPoint = line[#line]\n            if endPoint[1] == startPoint[1] and endPoint[2] == startPoint[2] then\n                render[c - 4] = ' Z'\n                render[c - 3] = ''\n                render[c - 2] = ''\n                render[c - 1] = ''\n                c = c - 3\n            end\n        end\n    end\nend\nrender[c] = [[\"/>]]\nc = c + 1\nlogRender.addValue(system.getTime() - t0)\n\nlocal num = 0\nif pointsArray[level] ~= nil then\n    num = #pointsArray[level]\nend\n\nlocal t1 = system.getTime()\nrender[c] = [[</g><text x=10 y=300 fill=white>Level: ]] \nrender[c + 1] = level\nrender[c + 2] = \"(\"\nrender[c + 3] = num\nrender[c + 4] = \")\"\nrender[c + 5] = [[</text>]]\nrender[c + 6] = [[<text x=10 y=320 fill=white>Mirror Mode: ]]\nrender[c + 7] = tostring(mirror)\nrender[c + 8] = [[</text>]]\nrender[c + 9] = [[<text x=10 y=340 fill=white>Line Mode: ]]\nrender[c + 10] = tostring(line)\nrender[c + 11] = [[</text>]]\nrender[c + 12] = [[<text x=10 y=360 fill=white>Connect Mode: ]]\nrender[c + 13] = tostring(closed)\nrender[c + 14] = [[</text>]]\nc = c + 15\n\nlocal Logs = Logs\nfor k,l in pairs(Logs.getLogs()) do\n    render[c] = '<text y=' \n    render[c + 1] = (k-1)*18 + 40 \n    render[c + 2] = ' fill=white>' \n    render[c + 3] =  l\n    render[c + 4] = '</text>'\n    c = c + 5\n    if Logs.Logs[k].Type == 'time' then\n        render[c] = '<rect x=300 y=' ..(k-1)*18+20 ..' height=5 fill=cyan width=' .. Logs.Logs[k].getValue()*50000 ..' />'\n        c = c + 1\n    end\nend\nrender[c] = [[</svg>]]\nlogOther.addValue(system.getTime() - t1)\n\n\nlocal t2 = system.getTime()\nlocal rendered = table.concat(render)\nlogConcat.addValue(system.getTime() - t2)\n\nsystem.setScreen(rendered)\nlogUpdate.addValue(system.getTime() - t0)\n","filter":{"args":[{"value":"update"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"1"},{"code":"-- Credit to Elias for suggesting seperating processing of the points and rendering\nlocal t0 = system.getTime()\nlocal cameraPos = {0, 0, dist}\nlocal offset = {0, 50, 0}\n\n-- Create the model and view matrices.\nlocal model, view = getMatrix(math.rad(heading), math.rad(pitch), math.rad(roll), 0, 0, 0, cameraPos)\nlogCompute.addValue(system.getTime() - t0)\n\n--Compute and project the points of the model\nlocal t1 = system.getTime()\nship = project(pointsArray, model, view, offset)\n\nlogProject.addValue(system.getTime() - t1)\n\nheading = heading+0.5\n--roll = roll+0.5\n--pitch = pitch+0.5\n\nlogFixed.addValue(system.getTime() - t0)","filter":{"args":[{"value":"fixed_1"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"2"},{"code":"dist = dist + system.getMouseWheel() * -10","filter":{"args":[{"value":"fixed_2"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"3"},{"code":"if mirror then\n    level = level + 2\n    if pointsArray[level - 1] == nil then\n        pointsArray[level - 1] = {}\n        pointsArray[level] = {}\n    elseif pointsArray[level] == nil then\n        pointsArray[level] = {}\n    end\nelse\n    level = level + 1\n    if pointsArray[level] == nil then\n        pointsArray[level] = {}\n    end\nend","filter":{"args":[{"value":"option5"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"4"},{"code":"local vec3 = require(\"cpml.vec3\")\nlocal utils = require(\"cpml.utils\")\nlocal hp = core.getHitPoints()\nlocal coreOffset = 16\nif hp > 10000 then\n    coreOffset = 128\nelseif hp > 1000 then\n    coreOffset = 64\nelseif hp > 150 then\n    coreOffset = 32\nend\n\nfunction offset(position)\n    local x = position.x - coreOffset\n    local y = position.y - coreOffset\n    local z = position.z - coreOffset\n    return vec3(utils.round(x * 4,0.1) - 0.5, utils.round(y * 4,0.1) - 0.5, utils.round(z * 4, 0.1) - 0.8)\nend\n\nlocal elementList = core.getElementIdList()\ntable.sort(elementList)\nlocal firstPos = nil\nlocal secondPos = nil\nif line then\n    for d = elementCount + 1, #elementList, 2 do\n        for i = 0, 1 do\n            local elementId = elementList[d+i]\n            local elementType = core.getElementTypeById(elementId)\n            if elementType == \"Adjustor\" then\n                local cords = offset(vec3(core.getElementPositionById(elementId)))\n                system.print(\"Added Point: \" .. tostring(cords) .. \" (\" .. #pointsArray[level] .. \")\")\n                pointsArray[level][#pointsArray[level] + 1] = {cords.x, cords.y, cords.z}\n                if mirror then\n                    local mirrorPos = vec3(-cords.x, cords.y, cords.z)\n                    pointsArray[level - 1][#pointsArray[level - 1] + 1] = {mirrorPos.x, mirrorPos.y, mirrorPos.z}\n                    system.print(\"Added Point: \" .. tostring(mirrorPos) .. \" (\" .. #pointsArray[level - 1] .. \")\")\n                end\n            end\n        end\n        if mirror then\n            level = level + 2\n            if pointsArray[level - 1] == nil then\n                pointsArray[level - 1] = {}\n                pointsArray[level] = {}\n            elseif pointsArray[level] == nil then\n                pointsArray[level] = {}\n            end\n        else\n            level = level + 1\n            if pointsArray[level] == nil then\n                pointsArray[level] = {}\n            end\n        end\n    end\n    \nelse\n    for i = elementCount + 1, #elementList do\n        local elementId = elementList[i]\n        local elementType = core.getElementTypeById(elementId)\n        if elementType == \"Adjustor\" then\n            local cords = offset(vec3(core.getElementPositionById(elementId)))\n\n            system.print(\"Added Point: \" .. tostring(cords) .. \" (\" .. #pointsArray[level] + 1 .. \")\")\n            pointsArray[level][#pointsArray[level] + 1] = {cords.x, cords.y, cords.z}\n            if mirror then\n                local mirrorPos = vec3(-cords.x, cords.y, cords.z)\n                pointsArray[level - 1][#pointsArray[level - 1] + 1] = {mirrorPos.x, mirrorPos.y, mirrorPos.z}\n                system.print(\"Added Point: \" .. tostring(mirrorPos) .. \" (\" .. #pointsArray[level - 1] + 1 .. \")\")\n                if secondPos == nil and closed then\n                    secondPos = mirrorPos\n                    system.print(\"Close Point: \" .. tostring(mirrorPos))\n                end\n            end\n            if firstPos == nil and closed then\n                firstPos = cords\n                system.print(\"Close Point: \" .. tostring(cords))\n            end\n        end\n    end\nend\nif firstPos ~= nil then\n    system.print(\"Added Point C: \" .. tostring(firstPos) .. \" (\" .. #pointsArray[level] + 1 .. \")\")\n    pointsArray[level][#pointsArray[level] + 1] = {firstPos.x, firstPos.y, firstPos.z}\nend\nif secondPos ~= nil then\n    system.print(\"Added Point C: \" .. tostring(secondPos) .. \" (\" .. #pointsArray[level - 1] + 1 .. \")\")\n    pointsArray[level - 1][#pointsArray[level - 1] + 1] = {secondPos.x, secondPos.y, secondPos.z}\nend","filter":{"args":[{"value":"option1"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"5"},{"code":"system.print(\"Deleted Point: \" .. tostring(vec3(pointsArray[level][#pointsArray[level]])))\npointsArray[level][#pointsArray[level]] = nil\nif mirror then\n    pointsArray[level - 1][#pointsArray[level - 1]] = nil\nend","filter":{"args":[{"value":"option2"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"6"},{"code":"local output = \"{\\n\"\nfor i,v in ipairs(pointsArray) do\n    if #v > 1 then\n        output = output .. \"\t{\\n\"\n        for d,k in ipairs(v) do\n            output = output .. \"\t\t{\" .. k[1] .. \",\" .. k[2] .. \",\" .. k[3] .. \"},\\n\"\n        end\n        output = string.sub(output, 1, #output - 2) .. \"\t},\\n\"\n    end\nend\noutput = string.sub(output, 1, #output - 2) .. \"}\"\ndisplay.setHTML(output)","filter":{"args":[{"value":"option9"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"7"},{"code":"if closed then\n    closed = false\nelse\n    closed = true\nend","filter":{"args":[{"value":"option4"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"8"},{"code":"if line then\n    line = false\nelse\n    line = true\nend","filter":{"args":[{"value":"option8"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"9"},{"code":"if mirror then\n    mirror = false\nelse\n    mirror = true\nend","filter":{"args":[{"value":"option3"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"10"},{"code":"if mirror then\n    level = level - 2\nelse\n    level = level - 1\nend","filter":{"args":[{"value":"option7"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"11"}],"methods":[],"events":[]}
