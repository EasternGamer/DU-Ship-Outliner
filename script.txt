{"slots":{"0":{"name":"core","type":{"events":[],"methods":[]}},"1":{"name":"display","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"pointsArray = {\n\t{},\n     {}\n}\n\nlevel = #pointsArray\n\nfunction transformPointVec3(vec, matrix)\n    return vec3(vec.x * matrix[1] + vec.y * matrix[4] + vec.z * matrix[7], \n                vec.x * matrix[2] + vec.y * matrix[5] + vec.z * matrix[8], \n                vec.x * matrix[3] + vec.y * matrix[6] + vec.z * matrix[9]\n           )\nend\n\nfunction multiply(matrix1, matrix2)\n    local result = {0, 0, 0, 0, 0, 0, 0, 0, 0}\n        for row = 0, 2, 1 do\n            for col = 0, 2, 1 do\n                for i = 0, 2, 1 do\n                    result[row * 3 + col + 1] = result[row * 3 + col + 1] + matrix1[row * 3 + i + 1] * matrix2[i * 3 + col + 1]\n                end\n            end\n        end\n        return result;\nend\n\nfunction getMatrix(heading, pitch, roll)\n    local rollTransform = {\n                   math.cos(roll), 0, math.sin(roll),\n                   0,              1,              0,\n                   -math.sin(roll), 0, math.cos(roll)}\n    local headingTransform = {\n                      math.cos(heading), -math.sin(heading), 0, \n                      math.sin(heading), math.cos(heading),  0, \n                      0,                 0,                  1}\n    local pitchTransform = {\n                    1,                0,               0, \n                    0,  math.cos(pitch), math.sin(pitch), \n                    0, -math.sin(pitch), math.cos(pitch)}\n    local t = multiply(multiply(headingTransform, pitchTransform), rollTransform)\n    return t\nend\n\nheading = 0\nroll = 0\npitch = 0\nclosed = false\nmirror = true\nline = false\n\nelementCount = #core.getElementIdList()\nsystem.showScreen(1)","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"0"},{"code":"if mirror then\n    level = level + 2\n    if pointsArray[level - 1] == nil then\n        pointsArray[level - 1] = {}\n        pointsArray[level] = {}\n    elseif pointsArray[level] == nil then\n        pointsArray[level] = {}\n    end\nelse\n    level = level + 1\n    if pointsArray[level] == nil then\n        pointsArray[level] = {}\n    end\nend","filter":{"args":[{"value":"option5"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"1"},{"code":"local vec3 = require(\"cpml.vec3\")\nlocal utils = require(\"cpml.utils\")\nlocal hp = core.getHitPoints()\nlocal coreOffset = 16\nif hp > 10000 then\n    coreOffset = 128\nelseif hp > 1000 then\n    coreOffset = 64\nelseif hp > 150 then\n    coreOffset = 32\nend\n\nfunction offset(position)\n    local x = position.x - coreOffset\n    local y = position.y - coreOffset\n    local z = position.z - coreOffset\n    return vec3(utils.round(x * 4,0.1) - 0.5, utils.round(y * 4,0.1) - 0.5, utils.round(z * 4, 0.1) - 0.8)\nend\n\nlocal elementList = core.getElementIdList()\ntable.sort(elementList)\nlocal firstPos = nil\nlocal secondPos = nil\nif line then\n    for d = elementCount + 1, #elementList, 2 do\n        for i = 0, 1 do\n            local elementId = elementList[d+i]\n            local elementType = core.getElementTypeById(elementId)\n            if elementType == \"Adjustor\" then\n                local cords = offset(vec3(core.getElementPositionById(elementId)))\n                system.print(\"Added Point: \" .. tostring(cords) .. \" (\" .. #pointsArray[level] .. \")\")\n                pointsArray[level][#pointsArray[level] + 1] = cords\n                if mirror then\n                    local mirrorPos = vec3(-cords.x, cords.y, cords.z)\n                    pointsArray[level - 1][#pointsArray[level - 1] + 1] = mirrorPos\n                    system.print(\"Added Point: \" .. tostring(mirrorPos) .. \" (\" .. #pointsArray[level - 1] .. \")\")\n                end\n            end\n        end\n        if mirror then\n            level = level + 2\n            if pointsArray[level - 1] == nil then\n                pointsArray[level - 1] = {}\n                pointsArray[level] = {}\n            elseif pointsArray[level] == nil then\n                pointsArray[level] = {}\n            end\n        else\n            level = level + 1\n            if pointsArray[level] == nil then\n                pointsArray[level] = {}\n            end\n        end\n    end\n    \nelse\n    for i = elementCount + 1, #elementList do\n        local elementId = elementList[i]\n        local elementType = core.getElementTypeById(elementId)\n        if elementType == \"Adjustor\" then\n            local cords = offset(vec3(core.getElementPositionById(elementId)))\n\n            system.print(\"Added Point: \" .. tostring(cords) .. \" (\" .. #pointsArray[level] + 1 .. \")\")\n            pointsArray[level][#pointsArray[level] + 1] = cords\n            if mirror then\n                local mirrorPos = vec3(-cords.x, cords.y, cords.z)\n                pointsArray[level - 1][#pointsArray[level - 1] + 1] = mirrorPos\n                system.print(\"Added Point: \" .. tostring(mirrorPos) .. \" (\" .. #pointsArray[level - 1] + 1 .. \")\")\n                if secondPos == nil and closed then\n                    secondPos = mirrorPos\n                    system.print(\"Close Point: \" .. tostring(mirrorPos))\n                end\n            end\n            if firstPos == nil and closed then\n                firstPos = cords\n                system.print(\"Close Point: \" .. tostring(cords))\n            end\n        end\n    end\nend\nif firstPos ~= nil then\n    system.print(\"Added Point C: \" .. tostring(firstPos) .. \" (\" .. #pointsArray[level] + 1 .. \")\")\n    pointsArray[level][#pointsArray[level] + 1] = firstPos\nend\nif secondPos ~= nil then\n    system.print(\"Added Point C: \" .. tostring(secondPos) .. \" (\" .. #pointsArray[level - 1] + 1 .. \")\")\n    pointsArray[level - 1][#pointsArray[level - 1] + 1] = secondPos\nend","filter":{"args":[{"value":"option1"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"2"},{"code":"system.print(\"Deleted Point: \" .. tostring(pointsArray[level][#pointsArray[level]]))\npointsArray[level][#pointsArray[level]] = nil\nif mirror then\n    pointsArray[level - 1][#pointsArray[level - 1]] = nil\nend","filter":{"args":[{"value":"option2"}],"signature":"actionStop(action)","slotKey":"-2"},"key":"3"},{"code":"local output = \"{\\n\"\nfor i,v in ipairs(pointsArray) do\n    output = output .. \"\t{\\n\"\n    for d,k in ipairs(v) do\n        output = output .. \"\t\tvec3(\" .. k.x .. \",\" .. k.y .. \",\" .. k.z .. \"),\\n\"\n    end\n    output = string.sub(output, 1, #output - 2) .. \"\t},\\n\"\nend\noutput = string.sub(output, 1, #output - 2) .. \"}\"\ndisplay.setHTML(output)","filter":{"args":[{"value":"option9"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"4"},{"code":"local original = system.getTime()\nlocal width = system.getScreenWidth() / 2\nlocal height = system.getScreenHeight() / 2\nlocal matrix = getMatrix(math.rad(roll), math.rad(pitch + 60), math.rad(heading))\n\nlocal polylines = {}\nlocal counter = 1\n\nfor i,v in ipairs(pointsArray) do\n    polylines[counter] = \"<polyline points=\\\"\"\n    counter = counter + 1\n    local colour = \"white\"\n    if mirror then\n        if i == level or i == (level - 1) then\n            colour = \"green\"\n        end\n    else\n        if i == level then\n            colour = \"green\"\n        end\n    end\n    for d,l in ipairs(v) do\n        local point = transformPointVec3(l, matrix)\n        polylines[counter] = \" \" .. point.x * 5 + width .. \",\" .. point.y * 5 + height\n        counter = counter + 1\n    end\n    polylines[counter] = [[\" style=\"fill:none;stroke:]].. colour ..[[;stroke-width:3\"/>]]\n    counter = counter + 1\nend\n\nlocal html = [[\n<style>\nsvg{\n  width: ]] .. width * 2 .. [[px;\n  height: ]] .. height * 2 .. [[px;\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  filter: drop-shadow(0 0 0.75rem crimson);\n}\n</style>\n<svg viewBox=\"0 0 ]] .. width * 2 .. [[ ]] .. height * 2 .. [[\">\n\t<g>\n\t\t]] .. table.concat(polylines) .. [[\n\t</g>\n]]\n\nlocal num = 0\nif pointsArray[level] ~= nil then\n    num = #pointsArray[level]\nend\nhtml = html .. [[<text x=10 y=300 fill=white>Level: ]] .. level .. \"(\" .. num .. \")\" .. [[</text>]]\nhtml = html .. [[<text x=10 y=320 fill=white>Mirror Mode: ]] .. tostring(mirror) .. [[</text>]]\nhtml = html .. [[<text x=10 y=340 fill=white>Line Mode: ]] .. tostring(line) .. [[</text>]]\nhtml = html .. [[<text x=10 y=360 fill=white>Connect Mode: ]] .. tostring(closed) .. [[</text>]]\nhtml = html .. [[</svg>]]\n--system.print(html)\nsystem.setScreen(html)\nheading = heading + 1\n--roll = roll + 1","filter":{"args":[],"signature":"update()","slotKey":"-2"},"key":"5"},{"code":"if closed then\n    closed = false\nelse\n    closed = true\nend","filter":{"args":[{"value":"option4"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"6"},{"code":"if line then\n    line = false\nelse\n    line = true\nend","filter":{"args":[{"value":"option8"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"7"},{"code":"if mirror then\n    mirror = false\nelse\n    mirror = true\nend","filter":{"args":[{"value":"option3"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"8"},{"code":"if mirror then\n    level = level - 2\nelse\n    level = level - 1\nend","filter":{"args":[{"value":"option7"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"9"}],"methods":[],"events":[]}
